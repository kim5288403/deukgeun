package com.example.deukgeun.authToken.application.service.implement;import com.example.deukgeun.authToken.application.service.AuthTokenApplicationService;import com.example.deukgeun.authToken.domain.model.entity.AuthToken;import com.example.deukgeun.authToken.domain.service.AuthTokenDomainService;import com.example.deukgeun.member.domain.entity.Member;import com.example.deukgeun.trainer.domain.model.aggregate.Trainer;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jws;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import lombok.RequiredArgsConstructor;import org.springframework.beans.factory.annotation.Value;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.annotation.PostConstruct;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Base64;import java.util.Date;import java.util.HashMap;@RequiredArgsConstructor@Servicepublic class AuthTokenApplicationServiceImpl implements AuthTokenApplicationService {    private final AuthTokenDomainService authTokenDomainService;    @Value("${jwt.secretKey}")    private String SECRET_KEY;    @Value("${jwt.authTokenTime}")    private long AUTH_TOKEN_TIME;    @Value("${jwt.refreshTokenTime}")    private long REFRESH_TOKEN_TIME;    @Value("${trainer.role}")    private String TRAINER_ROLE;    @Value("${member.role}")    private String MEMBER_ROLE;    /**     * 초기화 메소드입니다.     * 보호된 멤버 변수인 secretKey 를 Base64로 인코딩하여 초기화합니다.     */    @PostConstruct    protected void init() {        SECRET_KEY = Base64.getEncoder().encodeToString(SECRET_KEY.getBytes());    }    @Override    public void createToken(String authToken, String refreshToken) {        authTokenDomainService.createToken(authToken, refreshToken);    }    @Override    public String createAuthToken(String userPk, String roles) {        Claims claims = Jwts.claims().setSubject(userPk);        claims.put("roles", roles);        Date now = new Date();        return Jwts.builder()                .setClaims(claims)                .setIssuedAt(now)                .setExpiration(new Date(now.getTime() + AUTH_TOKEN_TIME))                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)                .compact();    }    @Override    public String createRefreshToken(String userPk, String roles) {        Claims claims = Jwts.claims().setSubject(userPk);        claims.put("roles", roles);        Date now = new Date();        return Jwts.builder()                .setClaims(claims)                .setIssuedAt(now)                .setExpiration(new Date(now.getTime() + REFRESH_TOKEN_TIME))                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)                .compact();    }    @Override    @Transactional    @CacheEvict(value = "token", key = "#authToken", cacheManager = "projectCacheManager")    public void deleteByAuthToken(String authToken) {        authTokenDomainService.deleteByAuthToken(authToken);    }    @Override    @Cacheable(value = "token", key = "#authToken", cacheManager = "projectCacheManager", unless = "#result == null")    public AuthToken findByAuthToken(String authToken) {        return authTokenDomainService.findByAuthToken(authToken);    }    @Override    public String getUserPk(String token) {        return Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token).getBody().getSubject();    }    @Override    public String getUserRole(String token) {        return (String) Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token).getBody().get("roles");    }    @Override    public HashMap<String, String> getLoginData(String loginType, String email) {        HashMap<String, String> loginData = new HashMap<>();        if (loginType.equals("trainer")) {            Trainer trainer = authTokenDomainService.findTrainerByEmail(email);            loginData.put("matchPassword", trainer.getPassword());            loginData.put("role", TRAINER_ROLE);        } else if (loginType.equals("member")) {            Member member = authTokenDomainService.findMemberByEmail(email);            loginData.put("matchPassword", member.getPassword());            loginData.put("role", MEMBER_ROLE);        }        return loginData;    }    @Override    public Authentication getAuthentication(String token, String role) {        String userPk = getUserPk(token);        UserDetails userDetails = null;        if (role.equals(TRAINER_ROLE)) {            userDetails = authTokenDomainService.loadUserByTrainerUsername(userPk);        } else if (role.equals(MEMBER_ROLE)) {            userDetails = authTokenDomainService.loadUserByMemberUsername(userPk);        }        assert userDetails != null;        return new UsernamePasswordAuthenticationToken(userDetails, "", userDetails.getAuthorities());    }    @Override    public String getRefreshTokenByAuthToken(String authToken) {        AuthToken token = authTokenDomainService.findByAuthToken(authToken);        String refreshToken;        if (token != null) {            refreshToken = token.getRefreshToken();        } else {            refreshToken = null;        }        return refreshToken;    }    @Override    public String resolveAuthToken(HttpServletRequest request) {        return request.getHeader("Authorization").replace("Bearer ", "");    }    @Override    public String setToken(String email, HttpServletResponse response, String role) {        String authToken = createAuthToken(email, role);        setHeaderAuthToken(response, authToken);        setHeaderRole(response, role);        String refreshToken = createRefreshToken(email, role);        authTokenDomainService.createToken(authToken, refreshToken);        return authToken;    }    @Override    public void setHeaderRole(HttpServletResponse response, String role) {        response.setHeader("role", role);    }    @Override    public void setHeaderAuthToken(HttpServletResponse response, String authToken) {        response.setHeader("Authorization", "Bearer " + authToken);    }    @Override    @CachePut(value = "token", key = "#authToken", cacheManager = "projectCacheManager", unless = "#result == null")    public void updateAuthToken(String authToken, String newAuthToken) {        authTokenDomainService.updateAuthToken(authToken, newAuthToken);    }    @Override    public boolean validateToken(String token) {        try {            Jws<Claims> claims = Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token);            return !claims.getBody().getExpiration().before(new Date());        } catch (Exception e) {            return false;        }    }}