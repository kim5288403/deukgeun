package com.example.deukgeun.authToken.application.service.implement;import com.example.deukgeun.authToken.application.service.AuthTokenApplicationService;import com.example.deukgeun.authToken.domain.model.entity.AuthToken;import com.example.deukgeun.authToken.domain.service.AuthTokenDomainService;import com.example.deukgeun.member.domain.entity.Member;import com.example.deukgeun.member.domain.service.MemberDomainService;import com.example.deukgeun.trainer.domain.model.aggregate.Trainer;import com.example.deukgeun.trainer.domain.service.TrainerDomainService;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jws;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import lombok.RequiredArgsConstructor;import org.springframework.beans.factory.annotation.Value;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.annotation.PostConstruct;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Base64;import java.util.Date;import java.util.HashMap;@RequiredArgsConstructor@Servicepublic class AuthTokenApplicationServiceImpl implements AuthTokenApplicationService {    private final AuthTokenDomainService authTokenDomainService;    private final MemberDomainService memberDomainService;    private final TrainerDomainService trainerDomainService;    @Value("${jwt.secretKey}")    private String SECRET_KEY;    @Value("${jwt.authTokenTime}")    private long AUTH_TOKEN_TIME;    @Value("${jwt.refreshTokenTime}")    private long REFRESH_TOKEN_TIME;    @Value("${trainer.role}")    private String TRAINER_ROLE;    @Value("${member.role}")    private String MEMBER_ROLE;    /**     * 초기화 메소드입니다.     * 보호된 멤버 변수인 secretKey 를 Base64로 인코딩하여 초기화합니다.     */    @PostConstruct    protected void init() {        SECRET_KEY = Base64.getEncoder().encodeToString(SECRET_KEY.getBytes());    }    /**     * 새로운 인증 토큰과 갱신 토큰을 생성하고 저장합니다.     *     * @param authToken    생성된 인증 토큰     * @param refreshToken 생성된 갱신 토큰     */    @Override    public void createToken(String authToken, String refreshToken) {        authTokenDomainService.createToken(authToken, refreshToken);    }    /**     * 사용자 식별자와 역할 정보를 사용하여 새로운 인증 토큰을 생성합니다.     *     * @param userPk 사용자의 고유 식별자     * @param roles  사용자의 역할 정보     * @return 생성된 인증 토큰     */    @Override    public String createAuthToken(String userPk, String roles) {        // JWT 클레임 생성        Claims claims = Jwts.claims().setSubject(userPk);        claims.put("roles", roles);        // 현재 시간 가져오기        Date now = new Date();        // JWT 빌더를 사용하여 토큰 생성        return Jwts.builder()                .setClaims(claims)                .setIssuedAt(now)                .setExpiration(new Date(now.getTime() + AUTH_TOKEN_TIME))                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)                .compact();    }    /**     * 사용자 식별자와 역할 정보를 사용하여 새로운 갱신 토큰을 생성합니다.     *     * @param userPk 사용자의 고유 식별자     * @param roles  사용자의 역할 정보     * @return 생성된 갱신 토큰     */    @Override    public String createRefreshToken(String userPk, String roles) {        // JWT 클레임 생성        Claims claims = Jwts.claims().setSubject(userPk);        claims.put("roles", roles);        // 현재 시간 가져오기        Date now = new Date();        // JWT 빌더를 사용하여 토큰 생성        return Jwts.builder()                .setClaims(claims)                .setIssuedAt(now)                .setExpiration(new Date(now.getTime() + REFRESH_TOKEN_TIME))                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)                .compact();    }    /**     * 주어진 인증 토큰을 사용하여 인증 정보를 삭제하고 캐시를 삭제합니다.     *     * @param authToken 삭제할 인증 토큰     */    @Override    @Transactional    @CacheEvict(value = "token", key = "#authToken", cacheManager = "projectCacheManager")    public void deleteByAuthToken(String authToken) {        authTokenDomainService.deleteByAuthToken(authToken);    }    /**     * 주어진 인증 토큰을 사용하여 인증 정보를 캐시에서 찾거나 데이터베이스에서 검색합니다.     * 검색 결과가 null 이 아닌 경우 캐시에 저장합니다.     *     * @param authToken 검색할 인증 토큰     * @return 검색한 인증 정보 또는 null (검색 결과가 없는 경우)     */    @Override    @Cacheable(value = "token", key = "#authToken", cacheManager = "projectCacheManager", unless = "#result == null")    public AuthToken findByAuthToken(String authToken) {        return authTokenDomainService.findByAuthToken(authToken);    }    /**     * 주어진 토큰에서 사용자의 고유 식별자 (User PK)를 추출합니다.     *     * @param token 추출할 사용자 고유 식별자가 포함된 토큰     * @return 추출한 사용자 고유 식별자 (User PK)     */    @Override    public String getUserPk(String token) {        return Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token).getBody().getSubject();    }    /**     * 주어진 토큰에서 사용자의 역할 정보를 추출합니다.     *     * @param token 추출할 사용자 역할 정보가 포함된 토큰     * @return 추출한 사용자 역할 정보     */    @Override    public String getUserRole(String token) {        return (String) Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token).getBody().get("roles");    }    /**     * 로그인 타입과 이메일을 기반으로 사용자의 로그인 데이터를 가져옵니다.     *     * @param loginType 로그인 유형 ("trainer" 또는 "member")     * @param email     사용자 이메일 주소     * @return 사용자의 로그인 데이터를 담은 HashMap     */    @Override    public HashMap<String, String> getLoginData(String loginType, String email) {        HashMap<String, String> loginData = new HashMap<>();        if (loginType.equals("trainer")) {            // 트레이너 로그인 타입인 경우            Trainer trainer = trainerDomainService.findByEmail(email);            loginData.put("matchPassword", trainer.getPassword());            loginData.put("role", TRAINER_ROLE);        } else if (loginType.equals("member")) {            // 멤버 로그인 타입인 경우            Member member = memberDomainService.findByEmail(email);            loginData.put("matchPassword", member.getPassword());            loginData.put("role", MEMBER_ROLE);        }        return loginData;    }    /**     * 주어진 토큰과 역할에 해당하는 사용자의 인증 정보를 가져옵니다.     *     * @param token 인증 토큰     * @param role  사용자의 역할 ("trainer" 또는 "member")     * @return 사용자의 인증 정보     */    @Override    public Authentication getAuthentication(String token, String role) {        String userPk = getUserPk(token);        UserDetails userDetails = null;        if (role.equals(TRAINER_ROLE)) {            userDetails = trainerDomainService.loadUserByTrainerUsername(userPk);        } else if (role.equals(MEMBER_ROLE)) {            userDetails = memberDomainService.loadUserByMemberUsername(userPk);        }        assert userDetails != null;        return new UsernamePasswordAuthenticationToken(userDetails, "", userDetails.getAuthorities());    }    /**     * 주어진 인증 토큰에 해당하는 갱신 토큰을 가져옵니다.     *     * @param authToken 인증 토큰     * @return 인증 토큰에 해당하는 갱신 토큰 또는 null (인증 토큰이 존재하지 않는 경우)     */    @Override    public String getRefreshTokenByAuthToken(String authToken) {        AuthToken token = authTokenDomainService.findByAuthToken(authToken);        String refreshToken;        if (token != null) {            refreshToken = token.getRefreshToken();        } else {            refreshToken = null;        }        return refreshToken;    }    /**     * HttpServletRequest에서 인증 토큰을 추출합니다.     *     * @param request HttpServletRequest 객체     * @return 추출한 인증 토큰 또는 null (헤더에 인증 토큰이 없는 경우)     */    @Override    public String resolveAuthToken(HttpServletRequest request) {        return request.getHeader("Authorization").replace("Bearer ", "");    }    /**     * 사용자의 이메일, 역할을 기반으로 새로운 인증 토큰 및 갱신 토큰을 생성하고     * HTTP 응답 헤더에 인증 토큰과 역할을 설정합니다. 그리고 토큰 정보를 데이터베이스에 저장합니다.     *     * @param email    사용자 이메일 주소     * @param response HttpServletResponse 객체     * @param role     사용자의 역할     * @return 생성된 인증 토큰     */    @Override    public String setToken(String email, HttpServletResponse response, String role) {        // 새로운 인증 토큰 생성        String authToken = createAuthToken(email, role);        // HTTP 응답 헤더에 인증 토큰 설정        setHeaderAuthToken(response, authToken);        // HTTP 응답 헤더에 역할 설정        setHeaderRole(response, role);        // 새로운 갱신 토큰 생성        String refreshToken = createRefreshToken(email, role);        // 토큰 정보를 데이터베이스에 저장        authTokenDomainService.createToken(authToken, refreshToken);        return authToken;    }    /**     * HTTP 응답 헤더에 사용자의 역할 정보를 설정합니다.     *     * @param response HttpServletResponse 객체     * @param role     사용자의 역할 정보     */    @Override    public void setHeaderRole(HttpServletResponse response, String role) {        response.setHeader("role", role);    }    /**     * HTTP 응답 헤더에 인증 토큰을 설정합니다.     *     * @param response   HttpServletResponse 객체     * @param authToken  설정할 인증 토큰     */    @Override    public void setHeaderAuthToken(HttpServletResponse response, String authToken) {        response.setHeader("Authorization", "Bearer " + authToken);    }    /**     * 주어진 인증 토큰과 새로운 인증 토큰을 사용하여 토큰 정보를 업데이트하고, 캐시를 수정합니다.     *     * @param authToken    기존 인증 토큰     * @param newAuthToken 새로운 인증 토큰     */    @Override    @CachePut(value = "token", key = "#authToken", cacheManager = "projectCacheManager", unless = "#result == null")    public void updateAuthToken(String authToken, String newAuthToken) {        authTokenDomainService.updateAuthToken(authToken, newAuthToken);    }    /**     * 주어진 토큰의 유효성을 검사합니다.     *     * @param token 검사할 인증 토큰     * @return 토큰이 유효하면 true, 그렇지 않으면 false     */    @Override    public boolean validateToken(String token) {        try {            // 주어진 시크릿 키로 토큰을 파싱하고 클레임 객체를 얻습니다.            Jws<Claims> claims = Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token);            // 토큰의 만료 시간을 현재 시간과 비교하여 유효성을 검사합니다.            return !claims.getBody().getExpiration().before(new Date());        } catch (Exception e) {            return false;        }    }}